# π
Каждая функция-алгоритм принимает на вход аргумент **n** - длину бесконечного ряда чисел, с помощью которого и вычисляется Пи. На практике это число означает количество итераций внутри определённого алгоритма - чем их больше, тем точнее будут вычисления, но и тем дольше время выполнения.

Помимо самих функций для подсчёта Пи, в проекте также присутствует 2 дополнительных метода: *measure()* и *compare()*. Первый измеряет скорость исполнения алгоритма, второй - точность вычисленного им значения (по знакам после запятой). Оба метода принимают в качестве аргументов само название функции и количество итераций **n**.

Все функции поддерживают как возврат значения, так и простой вывод результата.

___

В самом начале программы присутствует строка *getcontext().prec = 100*, отвечающая за точность после запятой в вещественных числах. Установленная точность распространяется не только на вычисленные значения Пи, но и вообще на бóльшую часть вычислений в программе, так как они происходят посредством библиотеки Decimal, для которой эта точность и определяется.

По-умолчанию точность стоит на 100 знаках после запятой (число Пи такой же точности используется и в функции *compare()*, чтобы сравнивать с ним результаты работы алгоритмов). Увеличение этого значения, вероятно, сделает вычисления более точными и медленными.

# Реализованные формулы
* ряд Лейбница

![](/formulas/leibniz.svg)
___
* ряд Мадхавы

![](/formulas/madhava.svg)
___
* ряд Нилаканта

![](/formulas/nilakantha.svg)
___
* формула Виета для приближения числа π

![](/formulas/viete.svg)
___
* формула Валлиса

![](/formulas/wallis_new.svg)
___
* первый метод Эйлера для нахождения суммы ряда обратных квадратов

![](/formulas/euler.svg)
___
* формула Мэчина с разложением её арктангенсов в ряд Тейлора

![](/formulas/machin.svg)

![](/formulas/taylor.svg)
___
* формула кратных рядов

![](/formulas/multiple_series.svg)
___
* формула двойного факториала

![](/formulas/double_factorial.svg)
